package de.jakobschaefer.htma.graphql

import com.apollographql.apollo.api.Optional
import com.apollographql.apollo.api.Query
import de.jakobschaefer.htma.HtmaRenderContext
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.thymeleaf.context.ITemplateContext
import org.thymeleaf.engine.AttributeName
import org.thymeleaf.model.IProcessableElementTag
import org.thymeleaf.processor.element.AbstractAttributeTagProcessor
import org.thymeleaf.processor.element.IElementTagStructureHandler
import org.thymeleaf.templatemode.TemplateMode
import kotlin.reflect.full.primaryConstructor

// syntax:
// <variableName> = ~{ <ServiceName> :: <QueryName>(parameters...) }
class HtmaQueryAttributeProcessor(dialectPrefix: String) :
    AbstractAttributeTagProcessor(
        TemplateMode.HTML, dialectPrefix, null, false, "query", true, 10_000, true) {
  override fun doProcess(
      context: ITemplateContext,
      tag: IProcessableElementTag,
      attributeName: AttributeName,
      attributeValue: String,
      structureHandler: IElementTagStructureHandler
  ) {
    val htma = HtmaRenderContext.fromContext(context)
    val gqlExpr = GraphQlExpressionHelper.parseGraphQlExpression(attributeValue, context)
    val queries =
      runBlocking {
        gqlExpr.assignments
          .map { (variableName, queryRef) ->
            async {
              val result =
                if (htma.graphqlCache.containsKey(queryRef)) {
                  htma.graphqlCache[queryRef]
                } else {
                  // Construct the query class that has been generated by apollo from the markup and data.
                  val queryClass = Class.forName("de.jakobschaefer.htma.${queryRef.serviceName}.${queryRef.operationName}").kotlin
                  val args = queryClass.primaryConstructor!!
                    .parameters
                    .mapIndexed { index, param ->
                      val value = queryRef.variables[param.name]
                      when (param.type.classifier) {
                        Optional::class -> Optional.presentIfNotNull(value)
                        else -> value
                      }
                    }.toTypedArray()
                  val query = queryClass.primaryConstructor!!.call(*args) as Query<*>

                  // Execute the query with the engine provided in the markup.
                  val engine = htma.graphqlServices[queryRef.serviceName] ?: throw IllegalStateException("Unknown GraphQL service ${queryRef.serviceName}")
                  val response = engine.query(query = query).toGraphQlResponse()
                  htma.graphqlCache[queryRef] = response
                  response
                }
              variableName to result
            }
          }.awaitAll()
      }.toMap()

    for (query in queries) {
      structureHandler.setLocalVariable(query.key, query.value)
    }
  }
}

